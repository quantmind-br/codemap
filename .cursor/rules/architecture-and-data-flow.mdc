---
description: Defines the core layered architecture, the Scanner -> Graph -> Analyze/Render pipeline, and rules for the central graph data model.
globs:
  - "**"
alwaysApply: true
---

# Project Architecture: The Code Analysis Pipeline

The `codemap` project follows a strict, unidirectional pipeline architecture: Code Scanning -> Knowledge Graph -> Analysis/Rendering. All development must respect these package boundaries and the flow of data.

## 1. Core Pipeline Stages and Package Responsibilities

The system operates as a layered pipeline, ensuring separation of concerns:

| Package | Role | Key Data Produced/Consumed |
| :--- | :--- | :--- |
| `@scanner` | Data Ingestion & AST Parsing (Tree-sitter). | Produces `scanner.Symbol` and `scanner.Dependency`. |
| `@graph` | Central Data Repository (Knowledge Graph). | Stores and queries `graph.Node`/`graph.Edge`. |
| `@analyze` | LLM Interaction & RAG Engine. | Consumes `graph` data, interacts with external APIs. |
| `@render` | Presentation Layer (TUI/CLI Output). | Consumes `graph` and `scanner` data for visualization. |

## 2. Central Data Model: graph.CodeGraph

The `graph.CodeGraph` is the single source of truth for the codebase structure.

- **Persistence:** The graph is serialized using `encoding/gob` and stored in the binary file `.codemap/graph.gob`. Do not attempt to manually parse or modify this file.
- **Integrity Rule:** When loading the graph from disk (e.g., in `runQueryMode`), the `CodeGraph.RebuildIndexes()` method must be called immediately after deserialization to ensure in-memory maps are consistent.
- **Node IDs:** All graph nodes must use stable, deterministic IDs generated by the `graph.GenerateNodeID(path, symbol)` utility to support incremental indexing.

## 3. Configuration and Entry Points

- **Configuration:** The `@config` package manages all settings. Configuration is loaded once at startup and passed down to components (e.g., `analyze.NewClient(cfg)`).
- **Entry Point:** The `main.go` file acts as the central command router, dispatching control flow based on CLI flags (e.g., `--index`, `--explain`, `--deps`). All mode-specific logic resides in the `run*Mode` functions.